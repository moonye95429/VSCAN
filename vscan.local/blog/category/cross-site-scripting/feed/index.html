<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Cross-Site Scripting &#8211; VSCAN | 網站安全弱點檢測</title>
	<atom:link href="http://vscan.local/blog/category/cross-site-scripting/feed/" rel="self" type="application/rss+xml" />
	<link>http://vscan.local</link>
	<description>網站弱點掃描服務 &#124; 程式碼弱點掃描服務</description>
	<lastBuildDate>Sat, 04 Aug 2018 10:24:21 +0000</lastBuildDate>
	<language>zh-TW</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=6.9.1</generator>
	<item>
		<title>CSRF (Cross-Site Request Forgery)</title>
		<link>http://vscan.local/blog/csrf-cross-site-request-forgery/</link>
		
		<dc:creator><![CDATA[vscan]]></dc:creator>
		<pubDate>Thu, 03 May 2018 10:03:47 +0000</pubDate>
				<category><![CDATA[Cross-Site Scripting]]></category>
		<category><![CDATA[CSRF]]></category>
		<category><![CDATA[HTTP Header]]></category>
		<guid isPermaLink="false">http://vscan.local/?p=2481</guid>

					<description><![CDATA[<p>CSRF 為一種類似詐騙的手法，藉由偽造的第三方網站內容誘騙受害者連線，該受害者需已透過身分驗證拿到目標網站的 Session，導致在不知情狀況下，受害者開啟了...</p>
<p>這篇文章 <a rel="nofollow" href="http://vscan.local/blog/csrf-cross-site-request-forgery/">CSRF (Cross-Site Request Forgery)</a> 最早出現於 <a rel="nofollow" href="http://vscan.local">VSCAN | 網站安全弱點檢測</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p>CSRF 為一種類似詐騙的手法，藉由偽造的第三方網站內容誘騙受害者連線，該受害者需已透過身分驗證拿到目標網站的 Session，導致在不知情狀況下，受害者開啟了偽造網站後觸發了對目標網站以受害者身分的連線要求。</p>
<p>&nbsp;</p>
<p>該弱點導致攻擊者劫持受害者的 Session，等於攻擊者拿到了受害者的身分，並在不知情狀況下被操作未知行為，可能造成受害者的機敏資料洩漏或交易行為變更等後果。此攻擊行為與 <a href="http://vscan.local/blog/cross-site-scripting/" target="_blank" rel="noopener">XSS</a> 不同的地方在於未利用 Script 取得受害者機密資訊，而是直接利用受害者發出的連線進行操作，因此除了 Cookie 的保護外，也必須對機敏內容的連線做二次驗證，採用不信任的方式檢查。</p>
<p>&nbsp;</p>
<figure id="attachment_2483" aria-describedby="caption-attachment-2483" style="width: 592px" class="wp-caption aligncenter"><img fetchpriority="high" decoding="async" class="size-full wp-image-2483" src="http://vscan.local/wp-content/uploads/2018/08/csrf.jpg" alt="CSRF" width="592" height="309" srcset="http://vscan.local/wp-content/uploads/2018/08/csrf.jpg 592w, http://vscan.local/wp-content/uploads/2018/08/csrf-300x157.jpg 300w, http://vscan.local/wp-content/uploads/2018/08/csrf-239x125.jpg 239w" sizes="(max-width: 592px) 100vw, 592px" /><figcaption id="caption-attachment-2483" class="wp-caption-text">Cross-Site Request Forgery</figcaption></figure>
<p>&nbsp;</p>
<p>驗證的方向需能檢驗送出連線的使用者身分，以避免受害者在不知情狀況下被冒用身分，可參考方法如下，</p>
<ul>
<li>
<h4><strong> 檢查 <a href="http://vscan.local/blog/http-header-security/" target="_blank" rel="noopener">HTTP Header</a> 欄位</strong>：可透過檢查 Header 中的 Referer 欄位是否存在及是否為正常流程網域，藉此確認發送端的前一個頁面是否被偽造或合法使用。</h4>
</li>
<li>
<h4><strong>驗證 Token 參數</strong>：除了驗證 Cookie 的 Token 之外，還需另外在 Request 中放入隱藏的動態 Token 參數。</h4>
</li>
<li>
<h4><strong>辨識使用者資訊</strong>：取得使用者環境資訊如 IP 位址或瀏覽器的 User-Agent，若發現經變更即驗證失效或送出重複身份驗證需求。</h4>
</li>
</ul>
<p>&nbsp;</p>
<p>.NET 開發者可參考如下方法來進行：</p>
<p>取得 Referer 標頭 (HttpRequest.UrlReferrer / HttpWebRequest.Referer)</p>
<p><a href="https://msdn.microsoft.com/zh-tw/library/system.net.httpwebrequest.referer(v=vs.110).aspx" target="_blank" rel="noopener"><em>https://msdn.microsoft.com/zh-tw/library/system.net.httpwebrequest.referer(v=vs.110).aspx</em></a></p>
<p>&nbsp;</p>
<p>使用 ASP .NET Core 的 Antiforgery 防範</p>
<p><a href="https://docs.microsoft.com/zh-tw/aspnet/core/security/anti-request-forgery" target="_blank" rel="noopener"><em>https://docs.microsoft.com/zh-tw/aspnet/core/security/anti-request-forgery</em></a></p>
<p>&nbsp;</p>
<p>取得使用者資訊 (User-Agent)</p>
<p><a href="https://msdn.microsoft.com/zh-tw/library/system.web.httprequest.useragent(v=vs.110).aspx" target="_blank" rel="noopener"><em>https://msdn.microsoft.com/zh-tw/library/system.web.httprequest.useragent(v=vs.110).aspx</em></a></p>
<p>這篇文章 <a rel="nofollow" href="http://vscan.local/blog/csrf-cross-site-request-forgery/">CSRF (Cross-Site Request Forgery)</a> 最早出現於 <a rel="nofollow" href="http://vscan.local">VSCAN | 網站安全弱點檢測</a>。</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>Cross-Site Scripting</title>
		<link>http://vscan.local/blog/cross-site-scripting/</link>
		
		<dc:creator><![CDATA[vscan]]></dc:creator>
		<pubDate>Wed, 28 Feb 2018 14:40:16 +0000</pubDate>
				<category><![CDATA[Cross-Site Scripting]]></category>
		<category><![CDATA[HTTP Header]]></category>
		<category><![CDATA[Injection]]></category>
		<guid isPermaLink="false">http://vscan.local/?p=2441</guid>

					<description><![CDATA[<p>Cross-Site Scripting (XSS) 對網站而言，是一個大麻煩，不只是其弱點容易被發現與使用，被利用後所造成的後果更是無法預期! 現今幾乎所有的...</p>
<p>這篇文章 <a rel="nofollow" href="http://vscan.local/blog/cross-site-scripting/">Cross-Site Scripting</a> 最早出現於 <a rel="nofollow" href="http://vscan.local">VSCAN | 網站安全弱點檢測</a>。</p>
]]></description>
										<content:encoded><![CDATA[<p>Cross-Site Scripting (XSS) 對網站而言，是一個大麻煩，不只是其弱點容易被發現與使用，被利用後所造成的後果更是無法預期! 現今幾乎所有的網站都會使用到 Javascript，很少純粹使用 HTML 語言，這導致使用者必須強迫接受 script 指令，在這個前提下，XSS 就是利用用戶端執行 script 時，埋入惡意程式，進而掌握機密資訊或後門，來達成竊取身份或遠端監控等目標。</p>
<p>&nbsp;</p>
<p>Cross-Site Scripting 可以分為反射式(Reflected)、儲存式(Stored)：</p>
<ul>
<li>
<h4><a href="https://capec.mitre.org/data/definitions/591.html" target="_blank" rel="noopener">Reflected XSS</a>  利用網站從存取可從外部修改的參數時，未經驗證而被埋入惡意語法，通常是利用可供輸入的欄位表單或可經proxy 修改的參數等功能，埋入惡意 script 語法，再將惡意連結偽裝讓受害人點擊，藉此騙過伺服器驗證而被盜取用戶端的身分資訊，並傳至第三方站台做為收集或掌控。</h4>
</li>
<li>
<h4><a href="https://capec.mitre.org/data/definitions/592.html" target="_blank" rel="noopener">Stored XSS</a> 則為利用類似留言板等網站功能，將外部輸入的惡意語法直接儲存在資料庫，當每個用戶存取到該頁面時，都會讀取到該惡意行為而被攻擊，受害者的層面更為廣大。</h4>
</li>
</ul>
<p>&nbsp;</p>
<figure id="attachment_2472" aria-describedby="caption-attachment-2472" style="width: 580px" class="wp-caption alignnone"><img decoding="async" class="size-full wp-image-2472" src="http://vscan.local/wp-content/uploads/2018/03/RXSS.gif" alt="" width="580" height="389" /><figcaption id="caption-attachment-2472" class="wp-caption-text">Reflected XSS</figcaption></figure>
<p>&nbsp;</p>
<p>由此可知，XSS 的攻擊面向很多樣化，就算針對特殊符號阻擋，還是可能利用編碼或其他格式來構成script 語法，只要想辦法避開檢驗規則即可，而不像 <a href="http://vscan.local/blog/sql-injection/" target="_blank" rel="noopener">SQL injection</a> 只能符合 SQL 的語法，相對於HTML 格式嚴謹許多。就如從外部輸入 onmouseover=alert(document.cookie) ，其中沒使用到&lt; &gt;等跳脫字元，但瀏覽器認定為合法的HTML事件而被執行，再加上可編成其他格式來逃避驗證規則，難怪此弱點仍然是眾多駭客攻打網站的首選。</p>
<p>&nbsp;</p>
<p>防禦方法可參考如 <a href="http://vscan.local/blog/http-header-security/" target="_blank" rel="noopener">HTTP Header</a> 安全性所述，對 Header 加入安全設定防止被竊取機密資訊，或 <a href="http://vscan.local/blog/injection-attack/" target="_blank" rel="noopener">Injection Attack</a> 的通用原則，對可竄改的外部來源做過濾驗證，有幾項原則可參考：</p>
<ul>
<li>
<h4>不要將不信任資料放入 HTML 中，但通常難以達成。</h4>
</li>
<li>
<h4>不信任資料放入 HTML 前須先進行編碼特殊字元，例如 &amp;  &lt;  &gt;  &#8221;  &#8216; 及 / 等字元。</h4>
</li>
<li>
<h4>不信任資料不建議放入 Javascript ，極度危險，因為難以確認編碼目標。</h4>
</li>
<li>
<h4>不信任資料放入CSS 中需要經過編碼處理，HTML Style格式同樣會造成跳脫。</h4>
</li>
</ul>
<p>&nbsp;</p>
<p>當然最安全方法是使用白名單政策，可使用正則表示式(Regular Expression) 來限定外部參數的資料格式，但通常很難符合網站功能的需求，因此會採用黑名單方式，可藉由第三方套件或開發語言原生的安全套件來過濾跳脫字元，如 OWASP 的 <a href="https://www.owasp.org/index.php/Category:OWASP_Enterprise_Security_API" target="_blank" rel="noopener">ESAPI</a> 專案或微軟原生提供的 <a href="https://www.owasp.org/index.php/.NET_AntiXSS_Library" target="_blank" rel="noopener">AntiXSS</a> 套件等，都是經測試防禦效果較為全面的選擇，並有經過<a href="http://boldersecurity.github.io/encoder-comparison-reference/" target="_blank" rel="noopener">第三方單位</a>比較針對各字元編碼的成效。</p>
<p>&nbsp;</p>
<p><strong><em>ESAPI</em></strong></p>
<p><em>輸入端驗證</em><br />
<em> String validatedFirstName = ESAPI.validator().getValidInput(&#8220;FirstName&#8221;,</em><br />
<em> myForm.getFirstName(), &#8220;FirstNameRegex&#8221;, 255, false, errorList);</em><br />
<em> boolean isValidFirstName = ESAPI.validator().isValidInput(&#8220;FirstName&#8221;,</em><br />
<em> myForm.getFirstName(), &#8220;FirstNameRegex&#8221;, 255, false);</em></p>
<p><em>輸出端編碼</em><br />
<em> String safeOutput = ESAPI.encoder().encodeForHTML( clean encoded output Comment );</em></p>
<p>&nbsp;</p>
<p><strong><em>AntiXSS</em></strong></p>
<p><em>HtmlEncode Method： 將內容經過編碼</em></p>
<p><em>GetSafeHtml  Method： 輸出完整的HTML架構</em></p>
<p><em>GetSafeHtmlFragment  Method： 將輸入的HTML片段輸出</em></p>
<p>&nbsp;</p>
<p>這篇文章 <a rel="nofollow" href="http://vscan.local/blog/cross-site-scripting/">Cross-Site Scripting</a> 最早出現於 <a rel="nofollow" href="http://vscan.local">VSCAN | 網站安全弱點檢測</a>。</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>HTTP Header 安全性</title>
		<link>http://vscan.local/blog/http-header-security/</link>
		
		<dc:creator><![CDATA[vscan]]></dc:creator>
		<pubDate>Thu, 30 Mar 2017 14:20:12 +0000</pubDate>
				<category><![CDATA[Cross-Site Scripting]]></category>
		<category><![CDATA[CSRF]]></category>
		<category><![CDATA[HTTP Header]]></category>
		<guid isPermaLink="false">http://vscan.local/?p=2326</guid>

					<description><![CDATA[<p>&#160; HTTP Header 可視為網站與客戶在連線時的橋溝通梁，也就是遵照 HTTP 的協議，利用 Server 端的參數來告知客戶端瀏覽器需遵守其遊...</p>
<p>這篇文章 <a rel="nofollow" href="http://vscan.local/blog/http-header-security/">HTTP Header 安全性</a> 最早出現於 <a rel="nofollow" href="http://vscan.local">VSCAN | 網站安全弱點檢測</a>。</p>
]]></description>
										<content:encoded><![CDATA[<figure id="attachment_2340" aria-describedby="caption-attachment-2340" style="width: 509px" class="wp-caption aligncenter"><img decoding="async" class="wp-image-2340" title="HTTP Header" src="http://vscan.local/wp-content/uploads/2017/12/擷取.png" alt="HTTP Header to Google" width="509" height="312" srcset="http://vscan.local/wp-content/uploads/2017/12/擷取.png 644w, http://vscan.local/wp-content/uploads/2017/12/擷取-300x184.png 300w, http://vscan.local/wp-content/uploads/2017/12/擷取-239x147.png 239w" sizes="(max-width: 509px) 100vw, 509px" /><figcaption id="caption-attachment-2340" class="wp-caption-text">HTTP Header 範例</figcaption></figure>
<p>&nbsp;</p>
<p>HTTP Header 可視為網站與客戶在連線時的橋溝通梁，也就是遵照 HTTP 的協議，利用 Server 端的參數來告知客戶端瀏覽器需遵守其遊戲規則，你才能跟我進行連線溝通與確認是否繼續進行下一步動作，所以當客戶端發出需求時，Server 端可藉由回應來確認連線的安全性需求。</p>
<p>近來跟客戶討論網站安全性時，常會遇到程式碼修補上的困難，不外乎還需要開發人員的調整及測試時間等問題，其實可以先進行 HTTP Header 的安全性設定。<br />
就如 OWASP TOP 10 與 SANS/CWE TOP 25 所列弱點，常見的 <a href="http://vscan.local/blog/cross-site-scripting/" target="_blank" rel="noopener">XSS(Cross-Site Scripting)</a>與 CSRF(Cross-Site Requset Forgery)等弱點都可藉由調整 HTTP Header 來達成初步的防禦效果! OWASP 就有針對此發表了相關說明。</p>
<h4>HTTP Header 安全設定</h4>
<ul>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#hsts_bp" target="_blank" rel="noopener"><span style="fontfont-weight: 400; font-size: medium;">HTTP Strict Transport Security (HSTS)</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#hpkp_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">Public Key Pinning Extension for HTTP (HPKP)</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xfo_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">X-Frame-Options</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xxxsp_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">X-XSS-Protection</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xcto_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">X-Content-Type-Options</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#csp_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">Content-Security-Policy</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#xpcdp_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">X-Permitted-Cross-Domain-Policies</span></a></li>
<li style="font-weight: 400; text-align: left;"><a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#rp_bp" target="_blank" rel="noopener"><span style="font-weight: 400; font-size: medium;">Referrer-Policy</span></a></li>
</ul>
<p>&nbsp;</p>
<p>其中 HPKP 可綁定憑證，限定客戶端只能使用 Server 提供的憑證來連線，中間若有經過 Proxy或第三方憑證被置換時，連線都會無效！這專門在防範中間人攻擊(Man-in-the-Middle Attack)，也就是常會有第三方或駭客想藉由置換憑證來修改或窺看SSL加密的通訊內容，但透過加入 HPKP 的方式，將憑證的資訊綁入 Header，這樣客戶在連線時就可以比對是否為正確的憑證，才能放心的進行安全連線。</p>
<p>X-Frame-Options 可限定網域連線存取，也就是防範釣魚網站或 Clickjacking 等攻擊，藉由限制來源網域是否符合同源政策或是允許的白名單才可進行存取，避免有心人透過 iframe 或蓋台等方式來騙取受害者點擊造假的網站或連結，導致客戶機密資訊被竊取。</p>
<p>其他關於防範 XSS 攻擊的有 Content-Security-Policy 及 X-XSS-Protection，另外在設定 Cookies 時可帶入 Httponly 參數，限制只能透過 HTTP 方式取得 Cookie，若利用 Script 方式會被拒絕，一樣可以達成防禦的效果!</p>
<p>&nbsp;</p>
<p>利用調整 HTTP Header 的安全性，可謂有事半功倍的成效，但是這終究只是第一線的防禦並只能抵擋部份攻擊，根據資安的縱深防禦理論，須藉由定期的弱點掃描檢視網站，網站伺服器及程式碼持續性的安全性調整及更新，才是網站能長久安全的不二法門。</p>
<p>這篇文章 <a rel="nofollow" href="http://vscan.local/blog/http-header-security/">HTTP Header 安全性</a> 最早出現於 <a rel="nofollow" href="http://vscan.local">VSCAN | 網站安全弱點檢測</a>。</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
